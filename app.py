# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jQiV39sdy4BXyoFowiKquME7mnqchnA8
"""
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from scipy.optimize import nnls

# Load pretrained components
regressor = joblib.load("voting_regressor.pkl")
preprocessor = joblib.load("preprocessor.pkl")
mlb_menu = joblib.load("mlb_menu.pkl")
mlb_event = joblib.load("mlb_event.pkl")
nmf = joblib.load("nmf_model.pkl")
menu_avg_leftovers = joblib.load("menu_avg_leftovers.pkl")
data = pd.read_excel("current_processed_menu_data.xlsx")

# 메뉴와 이벤트 전처리
data["Menu"] = data["Menu"].astype(str).apply(lambda x: sorted([i.strip() for i in x.split(",")]))
data["Event"] = data["Event"].astype(str).apply(lambda x: sorted([i.strip() for i in x.split(",")]))

# Label maps
MEAL_TYPE_MAP = {"아침": "A", "점심": "B", "저녁": "C", "브런치": "D"}
DESSERT_MAP = {"없음": "0", "유제품": "1", "과일": "2", "과일푸딩": "3", "이온음료/ 에이드/ 탄산": "4", "핫바": "5", "마카롱/ 초콜릿/ 에너지바": "6"}
EVENT_MAP = {"주말, 공휴일": "1", "주중": "0", "유격": "4", "중대 전술훈련 및 기본 훈련": "3"}

def predict(meal_type, menu_items, dessert, event):
    menu_list = [item.strip() for item in menu_items.split(",")]
    avg_leftover = np.mean([menu_avg_leftovers.get(item, 0) for item in menu_list])

    menu_encoded = pd.DataFrame(mlb_menu.transform([menu_list]), columns=mlb_menu.classes_)
    event_encoded = pd.DataFrame(mlb_event.transform([[event]]), columns=mlb_event.classes_)
    input_df = pd.DataFrame({
        'Meal Type': [meal_type],
        'Dessert': [dessert],
        'Menu Avg Leftovers': [avg_leftover]
    })
    full_input = pd.concat([input_df, menu_encoded, event_encoded], axis=1)
    X_input = preprocessor.transform(full_input)

    total_pred = np.expm1(regressor.predict(X_input)[0])

    # NNLS 분배
    H = nmf.components_
    menu_vec = menu_encoded.values[0]
    active_idx = np.where(menu_vec > 0)[0]
    H_active = H[:, active_idx]
    A = H_active.T @ H_active + 1e-6 * np.eye(len(active_idx))
    b = H_active.T @ np.ones(H_active.shape[0]) * total_pred
    weights, _ = nnls(A, b)
    weights = weights / (weights.sum() + 1e-10) * total_pred

    # 오차 계산
    matched = data[(data["Meal Type"] == meal_type) &
                   (data["Dessert"] == dessert) &
                   (data["Menu"].apply(lambda x: sorted(x) == sorted(menu_list))) &
                   (data["Event"].apply(lambda x: sorted(x) == sorted([event])))]
    total_true = matched["leftovers"].values[0] if not matched.empty else total_pred
    delta_T = abs(total_pred - total_true)

    V = mlb_menu.transform(data["Menu"])
    W = nmf.transform(V)
    V_hat = W @ H
    recon_error_vector = np.abs(V - V_hat).max(axis=0)
    cond_H = np.linalg.cond(H_active)

    result = {}
    for i, idx in enumerate(active_idx):
        item = mlb_menu.classes_[idx]
        pred = weights[i]
        e_i = recon_error_vector[idx]
        bound = cond_H * delta_T + e_i
        corrected = max(pred - bound, 0)
        result[item] = round(corrected, 2)

    return total_pred, result

# 🎨 Streamlit UI
st.title("🍛 군 급식 잔반 예측 프로그램")
st.markdown("메뉴 정보를 입력하면 예상 잔반량을 예측합니다.")

meal_type_korean = st.selectbox("🍽️ 식사 종류 선택", list(MEAL_TYPE_MAP.keys()))
meal_type = MEAL_TYPE_MAP[meal_type_korean]

menu_items = st.text_input("🍲 메뉴 항목 입력 (쉼표로 구분)", "영양밥,콩나물국,비엔나소시지야채볶음,돼지고기감자조림")

dessert_korean = st.selectbox("🍰 디저트 선택", list(DESSERT_MAP.keys()))
dessert = DESSERT_MAP[dessert_korean]

event_korean = st.selectbox("🎯 행사 선택", list(EVENT_MAP.keys()))
event = EVENT_MAP[event_korean]

num_people = st.number_input("👥 식사 인원 수", min_value=1, value=100)

if st.button("🧮 예측하기"):
    with st.spinner("계산 중..."):
        total, indiv = predict(meal_type, menu_items, dessert, event)
        scaled_predictions = {
            k: f"{v * num_people / 1000:.2f} kg" for k, v in indiv.items()
        }
        st.success("✅ 예측 완료!")
        st.subheader(f"예상 전체 잔반량: {total * num_people / 1000:.2f} kg")
        st.write("### 🍽️ 개별 음식 잔반 예측 (오차 반영)")
        st.json(scaled_predictions)

st.markdown("---")
st.subheader("🔧 특정 비율로 잔반량 계산")

percentage = st.slider("🔧 예측 잔반의 몇 퍼센트를 반환할까요?", min_value=1, max_value=100, value=50, step=1)

if st.button("🔄 특정 비율로 잔반 계산하기"):
    with st.spinner("계산 중..."):
        total, indiv = predict(meal_type, menu_items, dessert, event)
        scaled_predictions = {
            k: f"{v * num_people * (percentage / 100) / 1000:.2f} kg" for k, v in indiv.items()
        }
        st.success(f"✅ 예측 완료! ({percentage}% 기준)")
        st.subheader(f"예상 전체 잔반량: {total * num_people * (percentage / 100) / 1000:.2f} kg")
        st.write(f"### 🍽️ 개별 음식 잔반 예측 ({percentage}% 기준, 오차 반영)")
        st.json(scaled_predictions)

