# -*- coding: utf-8 -*-
"""app
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1jQiV39sdy4BXyoFowiKquME7mnqchnA8
"""
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from scipy.optimize import nnls

# ============================
# Load pretrained components (ë¡œì»¬ ë””ë ‰í„°ë¦¬ ê·¸ëŒ€ë¡œ)
# ============================
regressor = joblib.load("voting_regressor.pkl")
preprocessor = joblib.load("preprocessor.pkl")
mlb_menu = joblib.load("mlb_menu.pkl")
mlb_event = joblib.load("mlb_event.pkl")
nmf = joblib.load("nmf_model.pkl")
menu_avg_leftovers = joblib.load("menu_avg_leftovers.pkl")

data = pd.read_excel("current_processed_menu_data.xlsx")
for col in ["Menu", "Event"]:
    data[col] = data[col].astype(str).apply(lambda x: sorted([i.strip() for i in x.split(",")]))

# ============================
# Label maps
# ============================
MEAL_TYPE_MAP = {"ì•„ì¹¨": "A", "ì ì‹¬": "B", "ì €ë…": "C", "ë¸ŒëŸ°ì¹˜": "D"}
DESSERT_MAP = {"ì—†ìŒ": "0", "ìœ ì œí’ˆ": "1", "ê³¼ì¼": "2", "ê³¼ì¼í‘¸ë”©": "3", "ì´ì˜¨ìŒë£Œ/ ì—ì´ë“œ/ íƒ„ì‚°": "4", "í•«ë°”": "5", "ë§ˆì¹´ë¡±/ ì´ˆì½œë¦¿/ ì—ë„ˆì§€ë°”": "6"}
EVENT_MAP = {"ì£¼ë§, ê³µíœ´ì¼": "1", "ì£¼ì¤‘": "0", "ìœ ê²©": "4", "ì¤‘ëŒ€ ì „ìˆ í›ˆë ¨ ë° ê¸°ë³¸ í›ˆë ¨": "3"}

# ============================
# Core prediction (predictionâ€‘margin ë°˜í™˜)
# ============================

def predict(meal_type: str, menu_items: str, dessert: str, event: str):
    menu_list = [i.strip() for i in menu_items.split(",")]
    avg_leftover = np.mean([menu_avg_leftovers.get(item, 0) for item in menu_list])

    menu_enc = pd.DataFrame(mlb_menu.transform([menu_list]), columns=mlb_menu.classes_)
    event_enc = pd.DataFrame(mlb_event.transform([[event]]), columns=mlb_event.classes_)
    base = pd.DataFrame({
        "Meal Type": [meal_type],
        "Dessert": [dessert],
        "Menu Avg Leftovers": [avg_leftover],
    })
    full = pd.concat([base, menu_enc, event_enc], axis=1)
    X = preprocessor.transform(full)

    total_pred = float(np.expm1(regressor.predict(X)[0]))

    # --- NNLS allocation ---
    H = nmf.components_
    menu_vec = menu_enc.values[0]
    idx = np.where(menu_vec > 0)[0]
    if idx.size == 0:
        return total_pred, {}

    H_act = H[:, idx]
    A = H_act.T @ H_act + 1e-6 * np.eye(len(idx))
    b = H_act.T @ np.ones(H_act.shape[0]) * total_pred
    w, _ = nnls(A, b)
    w = w / (w.sum() + 1e-10) * total_pred

        # --- Tight errorâ€‘bound correction (leveraged Î”T + recon error) ---
    matched = data[(data["Meal Type"] == meal_type) &
                   (data["Dessert"] == dessert) &
                   (data["Menu"].apply(lambda x: sorted(x) == sorted(menu_list))) &
                   (data["Event"].apply(lambda x: sorted(x) == sorted([event])))]
    total_true = matched["leftovers"].values[0] if not matched.empty else total_pred
    delta_T = abs(total_pred - total_true)

    V = mlb_menu.transform(data["Menu"])
    W = nmf.transform(V)
    V_hat = W @ H
    recon_err_vec = np.abs(V - V_hat).max(axis=0)

    from numpy.linalg import pinv
    P = H_act @ pinv(H_act)
    leverage = np.clip(np.diag(P), 1e-10, 1)
    K = len(idx)

    result = {}
    for loc_i, g_idx in enumerate(idx):
        pred = w[loc_i]
        margin = np.sqrt(leverage[loc_i] * K) * delta_T + recon_err_vec[g_idx]
        corrected = max(pred - margin, 0)
        result[mlb_menu.classes_[g_idx]] = round(corrected, 2)

    return total_pred, result

# ============================
# ğŸ¨ Streamlit UI
# ============================
st.set_page_config(page_title="êµ° ê¸‰ì‹ ì”ë°˜ ì˜ˆì¸¡", page_icon="ğŸ›")
st.title("ğŸ› êµ° ê¸‰ì‹ ì”ë°˜ ì˜ˆì¸¡ í”„ë¡œê·¸ë¨")
st.markdown("ë©”ë‰´ ì •ë³´ë¥¼ ì…ë ¥í•˜ë©´ ì˜ˆìƒ ì”ë°˜ëŸ‰ì„ ì˜ˆì¸¡í•©ë‹ˆë‹¤.")

meal_type_k = st.selectbox("ğŸ½ï¸ ì‹ì‚¬ ì¢…ë¥˜ ì„ íƒ", list(MEAL_TYPE_MAP.keys()))
menu_items = st.text_input("ğŸ² ë©”ë‰´ í•­ëª© ì…ë ¥ (ì‰¼í‘œë¡œ êµ¬ë¶„)", "ì˜ì–‘ë°¥,ì½©ë‚˜ë¬¼êµ­,ë¹„ì—”ë‚˜ì†Œì‹œì§€ì•¼ì±„ë³¶ìŒ,ë¼ì§€ê³ ê¸°ê°ìì¡°ë¦¼")
dessert_k = st.selectbox("ğŸ° ë””ì €íŠ¸ ì„ íƒ", list(DESSERT_MAP.keys()))
event_k = st.selectbox("ğŸ¯ í–‰ì‚¬ ì„ íƒ", list(EVENT_MAP.keys()))
num_people = st.number_input("ğŸ‘¥ ì‹ì‚¬ ì¸ì› ìˆ˜", min_value=1, value=100)

meal_type = MEAL_TYPE_MAP[meal_type_k]
dessert = DESSERT_MAP[dessert_k]
event = EVENT_MAP[event_k]

if st.button("ğŸ§® ì˜ˆì¸¡í•˜ê¸°"):
    with st.spinner("ê³„ì‚° ì¤‘..."):
        total, indiv = predict(meal_type, menu_items, dessert, event)
        scaled = {k: f"{v * num_people / 1000:.2f} kg" for k, v in indiv.items()}
        st.success("âœ… ì˜ˆì¸¡ ì™„ë£Œ!")
        st.subheader(f"ì˜ˆìƒ ì „ì²´ ì”ë°˜ëŸ‰: {total * num_people / 1000:.2f} kg")
        st.write("### ğŸ½ï¸ ê°œë³„ ìŒì‹ ì”ë°˜ ì˜ˆì¸¡ (ì˜¤ì°¨ ë°˜ì˜)")
        st.json(scaled)

st.markdown("---")
st.subheader("ğŸ”§ íŠ¹ì • ë¹„ìœ¨ë¡œ ì”ë°˜ëŸ‰ ê³„ì‚°")
percentage = st.slider("ğŸ”§ ì˜ˆì¸¡ ì”ë°˜ì˜ ëª‡ í¼ì„¼íŠ¸ë¥¼ ë°˜í™˜í• ê¹Œìš”?", 1, 100, 50, 1)

if st.button("ğŸ”„ íŠ¹ì • ë¹„ìœ¨ë¡œ ì”ë°˜ ê³„ì‚°í•˜ê¸°"):
    with st.spinner("ê³„ì‚° ì¤‘..."):
        total, indiv = predict(meal_type, menu_items, dessert, event)
        factor = percentage / 100
        scaled = {k: f"{v * num_people * factor / 1000:.2f} kg" for k, v in indiv.items()}
        st.success(f"âœ… ì˜ˆì¸¡ ì™„ë£Œ! ({percentage}% ê¸°ì¤€)")
        st.subheader(f"ì˜ˆìƒ ì „ì²´ ì”ë°˜ëŸ‰: {total * num_people * factor / 1000:.2f} kg")
        st.write(f"### ğŸ½ï¸ ê°œë³„ ìŒì‹ ì”ë°˜ ì˜ˆì¸¡ ({percentage}% ê¸°ì¤€, ì˜¤ì°¨ ë°˜ì˜)")
        st.json(scaled)
