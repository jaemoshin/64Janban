# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jQiV39sdy4BXyoFowiKquME7mnqchnA8
"""
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from scipy.optimize import nnls

# Load pretrained components
regressor = joblib.load("voting_regressor.pkl")
preprocessor = joblib.load("preprocessor.pkl")
mlb_menu = joblib.load("mlb_menu.pkl")
mlb_event = joblib.load("mlb_event.pkl")
nmf = joblib.load("nmf_model.pkl")
menu_avg_leftovers = joblib.load("menu_avg_leftovers.pkl")
data = pd.read_excel("current_processed_menu_data.xlsx")

# ë©”ë‰´ì™€ ì´ë²¤íŠ¸ ì „ì²˜ë¦¬
data["Menu"] = data["Menu"].astype(str).apply(lambda x: sorted([i.strip() for i in x.split(",")]))
data["Event"] = data["Event"].astype(str).apply(lambda x: sorted([i.strip() for i in x.split(",")]))

# Label maps
MEAL_TYPE_MAP = {"ì•„ì¹¨": "A", "ì ì‹¬": "B", "ì €ë…": "C", "ë¸ŒëŸ°ì¹˜": "D"}
DESSERT_MAP = {"ì—†ìŒ": "0", "ìœ ì œí’ˆ": "1", "ê³¼ì¼": "2", "ê³¼ì¼í‘¸ë”©": "3", "ì´ì˜¨ìŒë£Œ/ ì—ì´ë“œ/ íƒ„ì‚°": "4", "í•«ë°”": "5", "ë§ˆì¹´ë¡±/ ì´ˆì½œë¦¿/ ì—ë„ˆì§€ë°”": "6"}
EVENT_MAP = {"ì£¼ë§, ê³µíœ´ì¼": "1", "ì£¼ì¤‘": "0", "ìœ ê²©": "4", "ì¤‘ëŒ€ ì „ìˆ í›ˆë ¨ ë° ê¸°ë³¸ í›ˆë ¨": "3"}

def predict(meal_type, menu_items, dessert, event):
    menu_list = [item.strip() for item in menu_items.split(",")]
    avg_leftover = np.mean([menu_avg_leftovers.get(item, 0) for item in menu_list])

    menu_encoded = pd.DataFrame(mlb_menu.transform([menu_list]), columns=mlb_menu.classes_)
    event_encoded = pd.DataFrame(mlb_event.transform([[event]]), columns=mlb_event.classes_)
    input_df = pd.DataFrame({
        'Meal Type': [meal_type],
        'Dessert': [dessert],
        'Menu Avg Leftovers': [avg_leftover]
    })
    full_input = pd.concat([input_df, menu_encoded, event_encoded], axis=1)
    X_input = preprocessor.transform(full_input)

    total_pred = np.expm1(regressor.predict(X_input)[0])

    # NNLS ë¶„ë°°
    H = nmf.components_
    menu_vec = menu_encoded.values[0]
    active_idx = np.where(menu_vec > 0)[0]
    H_active = H[:, active_idx]
    A = H_active.T @ H_active + 1e-6 * np.eye(len(active_idx))
    b = H_active.T @ np.ones(H_active.shape[0]) * total_pred
    weights, _ = nnls(A, b)
    weights = weights / (weights.sum() + 1e-10) * total_pred

    # ì˜¤ì°¨ ê³„ì‚°
    matched = data[(data["Meal Type"] == meal_type) &
                   (data["Dessert"] == dessert) &
                   (data["Menu"].apply(lambda x: sorted(x) == sorted(menu_list))) &
                   (data["Event"].apply(lambda x: sorted(x) == sorted([event])))]
    total_true = matched["leftovers"].values[0] if not matched.empty else total_pred
    delta_T = abs(total_pred - total_true)

    V = mlb_menu.transform(data["Menu"])
    W = nmf.transform(V)
    V_hat = W @ H
    recon_error_vector = np.abs(V - V_hat).max(axis=0)
    cond_H = np.linalg.cond(H_active)

    result = {}
    for i, idx in enumerate(active_idx):
        item = mlb_menu.classes_[idx]
        pred = weights[i]
        e_i = recon_error_vector[idx]
        bound = cond_H * delta_T + e_i
        corrected = max(pred - bound, 0)
        result[item] = round(corrected, 2)

    return total_pred, result

# ğŸ¨ Streamlit UI
st.title("ğŸ› êµ° ê¸‰ì‹ ì”ë°˜ ì˜ˆì¸¡ í”„ë¡œê·¸ë¨")
st.markdown("ë©”ë‰´ ì •ë³´ë¥¼ ì…ë ¥í•˜ë©´ ì˜ˆìƒ ì”ë°˜ëŸ‰ì„ ì˜ˆì¸¡í•©ë‹ˆë‹¤.")

meal_type_korean = st.selectbox("ğŸ½ï¸ ì‹ì‚¬ ì¢…ë¥˜ ì„ íƒ", list(MEAL_TYPE_MAP.keys()))
meal_type = MEAL_TYPE_MAP[meal_type_korean]

menu_items = st.text_input("ğŸ² ë©”ë‰´ í•­ëª© ì…ë ¥ (ì‰¼í‘œë¡œ êµ¬ë¶„)", "ì˜ì–‘ë°¥,ì½©ë‚˜ë¬¼êµ­,ë¹„ì—”ë‚˜ì†Œì‹œì§€ì•¼ì±„ë³¶ìŒ,ë¼ì§€ê³ ê¸°ê°ìì¡°ë¦¼")

dessert_korean = st.selectbox("ğŸ° ë””ì €íŠ¸ ì„ íƒ", list(DESSERT_MAP.keys()))
dessert = DESSERT_MAP[dessert_korean]

event_korean = st.selectbox("ğŸ¯ í–‰ì‚¬ ì„ íƒ", list(EVENT_MAP.keys()))
event = EVENT_MAP[event_korean]

num_people = st.number_input("ğŸ‘¥ ì‹ì‚¬ ì¸ì› ìˆ˜", min_value=1, value=100)

if st.button("ğŸ§® ì˜ˆì¸¡í•˜ê¸°"):
    with st.spinner("ê³„ì‚° ì¤‘..."):
        total, indiv = predict(meal_type, menu_items, dessert, event)
        scaled_predictions = {
            k: f"{v * num_people / 1000:.2f} kg" for k, v in indiv.items()
        }
        st.success("âœ… ì˜ˆì¸¡ ì™„ë£Œ!")
        st.subheader(f"ì˜ˆìƒ ì „ì²´ ì”ë°˜ëŸ‰: {total * num_people / 1000:.2f} kg")
        st.write("### ğŸ½ï¸ ê°œë³„ ìŒì‹ ì”ë°˜ ì˜ˆì¸¡ (ì˜¤ì°¨ ë°˜ì˜)")
        st.json(scaled_predictions)

st.markdown("---")
st.subheader("ğŸ”§ íŠ¹ì • ë¹„ìœ¨ë¡œ ì”ë°˜ëŸ‰ ê³„ì‚°")

percentage = st.slider("ğŸ”§ ì˜ˆì¸¡ ì”ë°˜ì˜ ëª‡ í¼ì„¼íŠ¸ë¥¼ ë°˜í™˜í• ê¹Œìš”?", min_value=1, max_value=100, value=50, step=1)

if st.button("ğŸ”„ íŠ¹ì • ë¹„ìœ¨ë¡œ ì”ë°˜ ê³„ì‚°í•˜ê¸°"):
    with st.spinner("ê³„ì‚° ì¤‘..."):
        total, indiv = predict(meal_type, menu_items, dessert, event)
        scaled_predictions = {
            k: f"{v * num_people * (percentage / 100) / 1000:.2f} kg" for k, v in indiv.items()
        }
        st.success(f"âœ… ì˜ˆì¸¡ ì™„ë£Œ! ({percentage}% ê¸°ì¤€)")
        st.subheader(f"ì˜ˆìƒ ì „ì²´ ì”ë°˜ëŸ‰: {total * num_people * (percentage / 100) / 1000:.2f} kg")
        st.write(f"### ğŸ½ï¸ ê°œë³„ ìŒì‹ ì”ë°˜ ì˜ˆì¸¡ ({percentage}% ê¸°ì¤€, ì˜¤ì°¨ ë°˜ì˜)")
        st.json(scaled_predictions)

